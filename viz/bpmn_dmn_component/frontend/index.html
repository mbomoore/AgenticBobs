<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>BPMN / DMN Viewer (Streamlit Component)</title>

  <!-- Streamlit component helper (UMD) -->
  <script src="https://unpkg.com/streamlit-component-lib@2/dist/index.umd.js"></script>
  <script>
    // Normalize global for our code
    if (!window.Streamlit) {
      if (window.streamlitComponentLib && window.streamlitComponentLib.Streamlit) {
        window.Streamlit = window.streamlitComponentLib.Streamlit;
      } else if (window.streamlitComponent && window.streamlitComponent.Streamlit) {
        window.Streamlit = window.streamlitComponent.Streamlit;
      }
    }
  </script>

  <!-- Viewer styles -->
  <link rel="stylesheet" href="https://unpkg.com/bpmn-js@10.5.0/dist/assets/bpmn-js.css" />
  <link rel="stylesheet" href="https://unpkg.com/dmn-js@14.8.1/dist/assets/diagram-js.css" />
  <link rel="stylesheet" href="https://unpkg.com/dmn-js@14.8.1/dist/assets/dmn-font/css/dmn.css" />
  <link rel="stylesheet" href="https://unpkg.com/dmn-js@14.8.1/dist/dmn-js.css" />

  <style>
    :root {
      --bg: #ffffff;
      --fg: #111111;
      --panel: #f2f2f2;
      --panel-border: #ddd;
    }
    .dark {
      --bg: #0f1116;
      --fg: #e8eaed;
      --panel: #1a1d24;
      --panel-border: #2a2f3a;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: var(--bg);
      color: var(--fg);
    }

    #root {
      display: flex;
      flex-direction: column;
      width: 100%;
    }

    #toolbar {
      display: flex;
      gap: 8px;
      align-items: center;
      padding: 8px 10px;
      background: var(--panel);
      border-bottom: 1px solid var(--panel-border);
      user-select: none;
      flex-wrap: wrap;
    }
    #toolbar .btn {
      padding: 6px 10px;
      border: 1px solid var(--panel-border);
      background: transparent;
      color: var(--fg);
      border-radius: 6px;
      cursor: pointer;
    }
    #toolbar .btn:hover {
      filter: brightness(1.05);
    }
    #status {
      margin-left: auto;
      font-size: 12px;
      opacity: 0.8;
    }

    #container {
      width: 100%;
      position: relative;
      overflow: hidden;
      background: var(--bg);
    }

    #canvas {
      width: 100%;
      height: 100%;
    }

    /* Help text overlay when no XML */
    #placeholder {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      color: var(--fg);
      opacity: 0.7;
      font-size: 14px;
      padding: 24px;
      text-align: center;
    }
  </style>
</head>
<body>
  <div id="root">
    <div id="toolbar">
      <span id="modeLabel">Mode: —</span>
      <button class="btn" id="fitBtn">Fit</button>
      <button class="btn" id="zoomInBtn">Zoom +</button>
      <button class="btn" id="zoomOutBtn">Zoom −</button>
      <button class="btn" id="resetBtn">Reset</button>
      <span id="status">Ready</span>
    </div>
    <div id="container">
      <div id="canvas"></div>
      <div id="placeholder" style="display:none;">
        Provide XML via the component’s <code>xml</code> arg to render a diagram.
      </div>
    </div>
  </div>

  <script>
    // Dynamically load external scripts to avoid initial load blocking
    const Libs = {
      bpmn: {
        url: "https://unpkg.com/bpmn-js@10.5.0/dist/bpmn-viewer.production.min.js",
        global: "BpmnJS",
      },
      dmn: {
        url: "https://unpkg.com/dmn-js@14.8.1/dist/dmn-viewer.production.min.js",
        global: "DmnJS",
      },
    };

    function loadScriptOnce(url) {
      return new Promise((resolve, reject) => {
        if ([...document.scripts].some(s => s.src === url)) return resolve();
        const s = document.createElement('script');
        s.src = url;
        s.async = true;
        s.onload = () => resolve();
        s.onerror = () => reject(new Error(`Failed to load ${url}`));
        document.head.appendChild(s);
      });
    }

    async function ensureLib(mode) {
      try {
        if (mode === 'bpmn' && !window[Libs.bpmn.global]) {
          await loadScriptOnce(Libs.bpmn.url);
        }
        if (mode === 'dmn' && !window[Libs.dmn.global]) {
          await loadScriptOnce(Libs.dmn.url);
        }
      } catch (e) {
        setStatus((e && e.message) || 'Library load error');
      }
    }
    const root = document.getElementById("root");
    const container = document.getElementById("container");
    const canvas = document.getElementById("canvas");
    const placeholder = document.getElementById("placeholder");
    const modeLabel = document.getElementById("modeLabel");
    const status = document.getElementById("status");

    const fitBtn = document.getElementById("fitBtn");
    const zoomInBtn = document.getElementById("zoomInBtn");
    const zoomOutBtn = document.getElementById("zoomOutBtn");
    const resetBtn = document.getElementById("resetBtn");

  let currentMode = null;   // "bpmn" | "dmn"
  let bpmnViewer = null;    // instance of BpmnJS
  let dmnViewer = null;     // instance of DmnJS
  let lastClickedId = null;
  let lastXml = null;       // remember last rendered XML to avoid re-import

    function setTheme(theme) {
      if (theme === "dark") {
        document.body.classList.add("dark");
      } else {
        document.body.classList.remove("dark");
      }
    }

    function setDimensions(heightPx, widthCss) {
      container.style.height = `${heightPx}px`;
      container.style.width = widthCss || "100%";
    }

    function killViewers() {
      if (bpmnViewer) { bpmnViewer.destroy(); bpmnViewer = null; }
      if (dmnViewer) { dmnViewer.destroy(); dmnViewer = null; }
      canvas.innerHTML = ""; // clears any residual layers
    }

    function setStatus(msg) {
      status.textContent = msg;
    }

    function setModeLabel(mode) {
      modeLabel.textContent = `Mode: ${mode.toUpperCase()}`;
    }

    function sendClicked(id) {
      lastClickedId = id || null;
      if (window.Streamlit && window.Streamlit.setComponentValue) {
        window.Streamlit.setComponentValue(lastClickedId);
      }
    }

    // Toolbar actions
    async function fitViewport() {
      try {
        if (currentMode === "bpmn" && bpmnViewer) {
          const canvasSvc = bpmnViewer.get("canvas");
          canvasSvc.zoom("fit-viewport");
          setStatus("Fit to viewport");
        } else if (currentMode === "dmn" && dmnViewer) {
          // DRD view provides canvas; decision tables have different surface.
          const activeView = dmnViewer.getActiveView();
          const activeViewer = dmnViewer.getActiveViewer();
          if (activeView && activeView.type === "drd") {
            const c = activeViewer.get("canvas");
            c.zoom("fit-viewport");
            setStatus("Fit DRD");
          } else {
            setStatus("Fit not applicable (decision table/text)");
          }
        }
      } catch (e) {
        setStatus(`Fit error: ${e.message}`);
      }
    }

    async function zoom(step = 0.2) {
      try {
        if (currentMode === "bpmn" && bpmnViewer) {
          const canvasSvc = bpmnViewer.get("canvas");
          const current = canvasSvc.zoom();
          canvasSvc.zoom(current + step, "auto");
          setStatus(`Zoom: ${(current + step).toFixed(2)}`);
        } else if (currentMode === "dmn" && dmnViewer) {
          const activeView = dmnViewer.getActiveView();
          const activeViewer = dmnViewer.getActiveViewer();
          if (activeView && activeView.type === "drd") {
            const c = activeViewer.get("canvas");
            const current = c.zoom();
            c.zoom(current + step, "auto");
            setStatus(`Zoom (DRD): ${(current + step).toFixed(2)}`);
          } else {
            setStatus("Zoom not applicable (decision table/text)");
          }
        }
      } catch (e) {
        setStatus(`Zoom error: ${e.message}`);
      }
    }

    function resetSelection() {
      sendClicked(null);
      setStatus("Selection cleared");
    }

    fitBtn.addEventListener("click", fitViewport);
    zoomInBtn.addEventListener("click", () => zoom(+0.2));
    zoomOutBtn.addEventListener("click", () => zoom(-0.2));
    resetBtn.addEventListener("click", resetSelection);

    // Render handler for Streamlit
  async function render(args) {
      const {
        xml,
        mode,
        height,
        width,
        theme,
        fit_on_load
      } = args || {};

      setTheme(theme || "light");
      setDimensions(height || 520, width || "100%");

      if (!xml || !xml.trim()) {
        killViewers();
        placeholder.style.display = "grid";
        setModeLabel("—");
        setStatus("No XML");
        if (window.Streamlit && window.Streamlit.setFrameHeight) {
          window.Streamlit.setFrameHeight(height || 520);
        }
        lastXml = null;
        return;
      }
      placeholder.style.display = "none";

      // Recreate viewers if mode changed
  if (mode !== currentMode) {
        killViewers();
        currentMode = mode;
        lastXml = null; // force re-import on mode switch
      }

      setModeLabel(currentMode);
      const xmlChanged = xml !== lastXml;
  // Lazy load required library for the selected mode
  await ensureLib(currentMode);

      if (currentMode === "bpmn") {
  if (!bpmnViewer) {
          bpmnViewer = new window.BpmnJS({
            container: canvas,
            height: "100%",
            width: "100%"
          });
        }
        if (xmlChanged) {
          bpmnViewer.importXML(xml).then(({ warnings }) => {
            lastXml = xml;
            if (fit_on_load) {
              const c = bpmnViewer.get("canvas");
              c.zoom("fit-viewport");
            }
            // Wire click events -> return element ID to Python
            const eventBus = bpmnViewer.get("eventBus");
            eventBus.off && eventBus.off("element.click"); // avoid duplicates if supported
            eventBus.on("element.click", function (e) {
              const id = e && e.element && e.element.id;
              sendClicked(id || null);
            });
            setStatus(warnings && warnings.length ? `Loaded with ${warnings.length} warning(s)` : "Loaded");
            if (window.Streamlit && window.Streamlit.setFrameHeight) {
              window.Streamlit.setFrameHeight(height || 520);
            }
          }).catch(err => {
            killViewers();
            setStatus(`BPMN import error: ${err.message}`);
            if (window.Streamlit && window.Streamlit.setFrameHeight) {
              window.Streamlit.setFrameHeight(height || 520);
            }
          });
        } else {
          // No re-import: just adjust frame height
          if (window.Streamlit && window.Streamlit.setFrameHeight) {
            window.Streamlit.setFrameHeight(height || 520);
          }
          setStatus("Ready");
        }

      } else if (currentMode === "dmn") {
  if (!dmnViewer) {
          dmnViewer = new window.DmnJS({
            container: canvas,
            height: "100%",
            width: "100%"
          });
        }
        if (xmlChanged) {
          dmnViewer.importXML(xml).then(() => {
            lastXml = xml;
            // Auto-select best view and fit if DRD
            const activeView = dmnViewer.getActiveView();
            const activeViewer = dmnViewer.getActiveViewer();

            if (fit_on_load && activeView && activeView.type === "drd") {
              const c = activeViewer.get("canvas");
              c.zoom("fit-viewport");
            }

            // Click support: DRD has canvas/eventBus; decisionTable/text have different APIs.
            if (activeView && activeView.type === "drd") {
              const eb = activeViewer.get("eventBus");
              eb.off && eb.off("element.click");
              eb.on("element.click", function (e) {
                const id = e && e.element && e.element.id;
                sendClicked(id || null);
              });
            } else {
              // For decision table/text views, just clear clicks to avoid stale selections
              sendClicked(null);
            }

            setStatus("Loaded");
            if (window.Streamlit && window.Streamlit.setFrameHeight) {
              window.Streamlit.setFrameHeight(height || 520);
            }
          }).catch(err => {
            killViewers();
            setStatus(`DMN import error: ${err.message}`);
            if (window.Streamlit && window.Streamlit.setFrameHeight) {
              window.Streamlit.setFrameHeight(height || 520);
            }
          });
        } else {
          if (window.Streamlit && window.Streamlit.setFrameHeight) {
            window.Streamlit.setFrameHeight(height || 520);
          }
          setStatus("Ready");
        }
      }
    }

    // Init
  function initWhenReady() {
      if (window.Streamlit && window.Streamlit.events && window.Streamlit.RENDER_EVENT) {
        window.Streamlit.events.addEventListener(window.Streamlit.RENDER_EVENT, (event) => {
          // Fire and forget; render handles its own async
          render(event.detail.args);
        });
        if (window.Streamlit.setComponentReady) window.Streamlit.setComponentReady();
        if (window.Streamlit.setFrameHeight) window.Streamlit.setFrameHeight(560);
    // Warm up library loads in background to avoid first-render delay
    ensureLib('bpmn');
    ensureLib('dmn');
      } else {
        // Wait for Streamlit ESM module to attach to window
        setTimeout(initWhenReady, 50);
      }
    }
      // Init
      function initWhenReady() {
        if (window.Streamlit) {
          // Announce readiness ASAP to avoid host timeout
          if (window.Streamlit.setComponentReady) window.Streamlit.setComponentReady();
          if (window.Streamlit.setFrameHeight) window.Streamlit.setFrameHeight(560);
          // Attach render handler once events API is available
          if (window.Streamlit.events && window.Streamlit.RENDER_EVENT) {
            window.Streamlit.events.addEventListener(window.Streamlit.RENDER_EVENT, (event) => {
              render(event.detail.args);
            });
            // Warm up libs after handshake
            ensureLib('bpmn');
            ensureLib('dmn');
            return; // fully initialized
          }
        }
        // Retry until the Streamlit bridge is fully available
        setTimeout(initWhenReady, 50);
      }
    initWhenReady();
  </script>
</body>
</html>
